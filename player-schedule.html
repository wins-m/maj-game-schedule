<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸ªäººæ—¶é—´è¡¨</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/schedule.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>ä¸ªäººæ—¶é—´è¡¨</h1>
            <a href="index.html" class="btn btn-secondary">è¿”å›åˆ†æ¡Œè¡¨</a>
        </header>

        <main>
            <div id="player-info" class="player-info"></div>
            
            <div class="schedule-instructions">
                <p>è¯·å‹¾é€‰æ‚¨æœªæ¥7å¤©çš„ç©ºé—²æ—¶é—´æ®µï¼ˆæ—©ã€ä¸­ã€æ™šï¼‰</p>
                <p class="batch-hint">ğŸ’¡ æç¤ºï¼šç‚¹å‡»æ—¥æœŸå¯æ‰¹é‡é€‰æ‹©æ•´è¡Œï¼Œç‚¹å‡»æ—¶æ®µå¯æ‰¹é‡é€‰æ‹©æ•´åˆ—</p>
            </div>

            <div id="schedule-table" class="schedule-table">
                <!-- æ—¶é—´è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>

            <div class="schedule-actions">
                <button id="save-schedule-btn" class="btn btn-primary">ä¿å­˜æ—¶é—´è¡¨</button>
                <button id="clear-schedule-btn" class="btn btn-secondary">æ¸…ç©ºé€‰æ‹©</button>
            </div>
        </main>
    </div>

    <script src="js/storage-api.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/game.js"></script>
    <script src="js/schedule.js"></script>
    <script>
        // ä¸ªäººæ—¶é—´è¡¨é¡µé¢é€»è¾‘
        (function() {
            // è·å–URLå‚æ•°
            const urlParams = new URLSearchParams(window.location.search);
            const playerId = parseInt(urlParams.get('playerId'));

            if (!playerId) {
                alert('ç¼ºå°‘é€‰æ‰‹IDå‚æ•°');
                window.location.href = 'index.html';
                return;
            }

            // è·Ÿè¸ªæ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹
            let hasUnsavedChanges = false;
            // è®°å½•åˆå§‹çŠ¶æ€ï¼Œç”¨äºæ¯”è¾ƒ
            let initialSelectedTimes = [];
            // å›¾è¡¨æ¸²æŸ“çŠ¶æ€æ ‡å¿—
            window.isRenderingChart = false;
            window.chartRendered = false;
            window.scoreChartInstance = null; // ç¡®ä¿åˆå§‹çŠ¶æ€ä¸ºnull

            // åˆå§‹åŒ–
            (async function() {
                try {
                    await Storage.init();
                    const player = await Storage.getPlayer(playerId);
                    
                    if (!player) {
                        alert('é€‰æ‰‹ä¸å­˜åœ¨');
                        window.location.href = 'index.html';
                        return;
                    }

                    // æ¸²æŸ“é€‰æ‰‹ä¿¡æ¯
                    const playerInfoEl = document.getElementById('player-info');
                    playerInfoEl.innerHTML = `
                        <h2>${player.name} çš„æ—¶é—´è¡¨</h2>
                        <p>å½“å‰ç§¯åˆ†ï¼š${player.totalScore}</p>
                        <div class="score-chart-container">
                            <h3>å†å²å¾—åˆ†è®°å½•</h3>
                            <canvas id="scoreChart" width="400" height="200"></canvas>
                        </div>
                    `;

                    // æ¸²æŸ“å†å²å¾—åˆ†å›¾è¡¨
                    setTimeout(() => {
                        if (!window.chartRendered) {
                            renderScoreChart(playerId);
                            window.chartRendered = true;
                        }
                    }, 50);

                    // æ¸²æŸ“æ—¶é—´è¡¨
                    await renderSchedule();
                    
                    // è®°å½•åˆå§‹çŠ¶æ€
                    initialSelectedTimes = await Schedule.getSelectedTimes(playerId);
                    hasUnsavedChanges = false;
                } catch (error) {
                    console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                    alert('åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                }
            })();

            // ç»‘å®šäº‹ä»¶
            document.getElementById('save-schedule-btn').addEventListener('click', saveSchedule);
            document.getElementById('clear-schedule-btn').addEventListener('click', clearSchedule);
            
            // ç»‘å®šè¿”å›æŒ‰é’®ï¼Œæ£€æŸ¥æœªä¿å­˜æ›´æ”¹
            document.querySelector('a[href="index.html"]').addEventListener('click', function(e) {
                if (hasUnsavedChanges) {
                    e.preventDefault();
                    if (Utils.confirm('æ‚¨æœ‰æœªä¿å­˜çš„æ›´æ”¹ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿæœªä¿å­˜çš„æ›´æ”¹å°†ä¸¢å¤±ã€‚')) {
                        window.location.href = 'index.html';
                    }
                }
            });
            
            // ç»‘å®šé¡µé¢å…³é—­äº‹ä»¶ï¼Œæ£€æŸ¥æœªä¿å­˜æ›´æ”¹
            window.addEventListener('beforeunload', function(e) {
                if (hasUnsavedChanges) {
                    e.preventDefault();
                    e.returnValue = 'æ‚¨æœ‰æœªä¿å­˜çš„æ›´æ”¹ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ';
                    return e.returnValue;
                }
            });

            // é¡µé¢å¸è½½æ—¶æ¸…ç†å›¾è¡¨
            window.addEventListener('unload', function() {
                if (window.scoreChartInstance) {
                    try {
                        window.scoreChartInstance.destroy();
                        window.scoreChartInstance = null;
                    } catch (e) {
                        console.warn('é¡µé¢å¸è½½æ—¶æ¸…ç†å›¾è¡¨å¤±è´¥:', e);
                    }
                }
            });

            /**
             * æ¸²æŸ“æ—¶é—´è¡¨
             */
            async function renderSchedule() {
                const days = Utils.getNextDays(7);
                const periods = Utils.getPeriods();
                const selectedTimes = await Schedule.getSelectedTimes(playerId);

                let html = '<table class="schedule-grid"><thead><tr><th>æ—¥æœŸ</th>';
                periods.forEach(period => {
                    html += `<th class="period-header" data-period="${period.key}">${period.name}</th>`;
                });
                html += '</tr></thead><tbody>';

                days.forEach(day => {
                    html += `<tr>
                        <td class="day-cell batch-select-row" data-date="${day.dateStr}">
                            <div class="day-name">${day.dateStr}</div>
                            <div class="weekday">æ˜ŸæœŸ${day.weekday}</div>
                        </td>`;
                    
                    periods.forEach(period => {
                        const timeKey = Utils.getTimeKey(day.dateStr, period.key);
                        const isSelected = selectedTimes.includes(timeKey);
                        html += `
                            <td class="time-cell">
                                <label class="time-checkbox">
                                    <input type="checkbox" 
                                           data-date="${day.dateStr}" 
                                           data-period="${period.key}"
                                           ${isSelected ? 'checked' : ''}>
                                    <span class="checkmark"></span>
                                </label>
                            </td>
                        `;
                    });
                    
                    html += '</tr>';
                });

                html += '</tbody></table>';

                document.getElementById('schedule-table').innerHTML = html;

                // ç»‘å®šå¤é€‰æ¡†äº‹ä»¶
                document.querySelectorAll('.time-checkbox input').forEach(checkbox => {
                    checkbox.addEventListener('change', async function() {
                        const date = this.dataset.date;
                        const period = this.dataset.period;
                        const updatedTimes = await Schedule.toggleTimeSlot(playerId, date, period);
                        // ç›´æ¥ä½¿ç”¨è¿”å›å€¼æ›´æ–°å¤é€‰æ¡†çŠ¶æ€ï¼Œé¿å…é‡å¤è¯·æ±‚
                        const timeKey = Utils.getTimeKey(date, period);
                        this.checked = updatedTimes.includes(timeKey);
                        
                        // æ ‡è®°æœ‰æœªä¿å­˜çš„æ›´æ”¹
                        markAsUnsaved();
                    });
                });

                // ç»‘å®šæ•´è¡Œé€‰æ‹©ï¼ˆç‚¹å‡»æ—¥æœŸå•å…ƒæ ¼ï¼‰
                document.querySelectorAll('.batch-select-row').forEach(cell => {
                    cell.addEventListener('click', async function(e) {
                        // å¦‚æœç‚¹å‡»çš„æ˜¯å¤é€‰æ¡†ï¼Œä¸è§¦å‘æ•´è¡Œé€‰æ‹©
                        if (e.target.closest('.time-checkbox')) return;
                        
                        const dateStr = this.dataset.date || 
                            this.querySelector('.day-name')?.textContent;
                        if (dateStr) {
                            await toggleRow(dateStr);
                        }
                    });
                });

                // ç»‘å®šæ•´åˆ—é€‰æ‹©ï¼ˆç‚¹å‡»æ—¶æ®µè¡¨å¤´ï¼‰
                document.querySelectorAll('.period-header').forEach(header => {
                    header.addEventListener('click', async function() {
                        const period = this.dataset.period;
                        await toggleColumn(period);
                    });
                });
            }

            /**
             * åˆ‡æ¢æ•´è¡Œé€‰æ‹©
             */
            async function toggleRow(dateStr) {
                const periods = Utils.getPeriods();
                let selectedTimes = await Schedule.getSelectedTimes(playerId);
                
                // æ£€æŸ¥è¯¥è¡Œæ˜¯å¦å…¨éƒ¨é€‰ä¸­
                const rowTimes = periods.map(p => Utils.getTimeKey(dateStr, p.key));
                const allSelected = rowTimes.every(timeKey => selectedTimes.includes(timeKey));
                
                // ä½¿ç”¨for...ofå¾ªç¯æ›¿ä»£forEachï¼Œä»¥æ”¯æŒawait
                for (const period of periods) {
                    const timeKey = Utils.getTimeKey(dateStr, period.key);
                    if (allSelected) {
                        // å…¨éƒ¨å–æ¶ˆ
                        if (selectedTimes.includes(timeKey)) {
                            selectedTimes = await Schedule.toggleTimeSlot(playerId, dateStr, period.key);
                        }
                    } else {
                        // å…¨éƒ¨é€‰ä¸­
                        if (!selectedTimes.includes(timeKey)) {
                            selectedTimes = await Schedule.toggleTimeSlot(playerId, dateStr, period.key);
                        }
                    }
                    // ä½¿ç”¨æ›´æ–°åçš„çŠ¶æ€æ›´æ–°å¤é€‰æ¡†ï¼Œé¿å…é‡å¤è¯·æ±‚
                    updateCheckboxState(dateStr, period.key, selectedTimes);
                }
                
                // æ ‡è®°æœ‰æœªä¿å­˜çš„æ›´æ”¹
                markAsUnsaved();
            }

            /**
             * åˆ‡æ¢æ•´åˆ—é€‰æ‹©
             */
            async function toggleColumn(period) {
                const days = Utils.getNextDays(7);
                let selectedTimes = await Schedule.getSelectedTimes(playerId);
                
                // æ£€æŸ¥è¯¥åˆ—æ˜¯å¦å…¨éƒ¨é€‰ä¸­
                const columnTimes = days.map(d => Utils.getTimeKey(d.dateStr, period));
                const allSelected = columnTimes.every(timeKey => selectedTimes.includes(timeKey));
                
                // ä½¿ç”¨for...ofå¾ªç¯æ›¿ä»£forEachï¼Œä»¥æ”¯æŒawait
                for (const day of days) {
                    const timeKey = Utils.getTimeKey(day.dateStr, period);
                    if (allSelected) {
                        // å…¨éƒ¨å–æ¶ˆ
                        if (selectedTimes.includes(timeKey)) {
                            selectedTimes = await Schedule.toggleTimeSlot(playerId, day.dateStr, period);
                        }
                    } else {
                        // å…¨éƒ¨é€‰ä¸­
                        if (!selectedTimes.includes(timeKey)) {
                            selectedTimes = await Schedule.toggleTimeSlot(playerId, day.dateStr, period);
                        }
                    }
                    // ä½¿ç”¨æ›´æ–°åçš„çŠ¶æ€æ›´æ–°å¤é€‰æ¡†ï¼Œé¿å…é‡å¤è¯·æ±‚
                    updateCheckboxState(day.dateStr, period, selectedTimes);
                }
                
                // æ ‡è®°æœ‰æœªä¿å­˜çš„æ›´æ”¹
                markAsUnsaved();
            }

            /**
             * æ›´æ–°å¤é€‰æ¡†çŠ¶æ€æ˜¾ç¤ºï¼ˆä½¿ç”¨å·²æä¾›çš„æ—¶é—´åˆ—è¡¨ï¼Œé¿å…é‡å¤è¯·æ±‚ï¼‰
             */
            function updateCheckboxState(dateStr, period, selectedTimes) {
                const checkbox = document.querySelector(
                    `input[data-date="${dateStr}"][data-period="${period}"]`
                );
                if (checkbox) {
                    const timeKey = Utils.getTimeKey(dateStr, period);
                    checkbox.checked = selectedTimes.includes(timeKey);
                }
            }

            /**
             * æ ‡è®°æœ‰æœªä¿å­˜çš„æ›´æ”¹
             */
            function markAsUnsaved() {
                // è·å–å½“å‰é€‰æ‹©çŠ¶æ€
                const currentSelectedTimes = [];
                document.querySelectorAll('.time-checkbox input:checked').forEach(checkbox => {
                    const date = checkbox.dataset.date;
                    const period = checkbox.dataset.period;
                    currentSelectedTimes.push(Utils.getTimeKey(date, period));
                });
                
                // æ¯”è¾ƒå½“å‰çŠ¶æ€å’Œåˆå§‹çŠ¶æ€
                const currentSorted = [...currentSelectedTimes].sort().join(',');
                const initialSorted = [...initialSelectedTimes].sort().join(',');
                hasUnsavedChanges = currentSorted !== initialSorted;
            }

            /**
             * ç”Ÿæˆæ‰€æœ‰é€‰æ‰‹ç©ºé—²æ—¶é—´çš„å¤‡ä»½æ–‡ä»¶ï¼ˆä¿å­˜åˆ°æœåŠ¡å™¨ï¼‰
             */
            async function generateBackupFile() {
                try {
                    const players = await Storage.getPlayers();
                    const schedules = await Storage.getSchedules();
                    
                    // æ„å»ºå¤‡ä»½æ•°æ®
                    const backupData = {
                        exportTime: new Date().toISOString(),
                        players: players.map(player => ({
                            id: player.id,
                            name: player.name
                        })),
                        schedules: schedules.map(schedule => ({
                            playerId: schedule.playerId,
                            playerName: players.find(p => p.id === schedule.playerId)?.name || `é€‰æ‰‹${schedule.playerId}`,
                            availableTimes: schedule.availableTimes || [],
                            updatedAt: schedule.updatedAt
                        }))
                    };
                    
                    // è°ƒç”¨æœåŠ¡å™¨APIä¿å­˜å¤‡ä»½æ–‡ä»¶
                    const result = await Storage.apiRequest('/backup-schedule', 'POST', backupData);
                    
                    if (result.success) {
                        console.log('å¤‡ä»½æ–‡ä»¶å·²ä¿å­˜åˆ°æœåŠ¡å™¨:', result.filename);
                        Utils.showMessage(`å¤‡ä»½æ–‡ä»¶å·²ä¿å­˜: ${result.filename}`, 'success');
                    } else {
                        throw new Error('æœåŠ¡å™¨è¿”å›å¤±è´¥');
                    }
                } catch (error) {
                    console.error('ä¿å­˜å¤‡ä»½æ–‡ä»¶å¤±è´¥:', error);
                    Utils.showMessage('ä¿å­˜å¤‡ä»½æ–‡ä»¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥', 'error');
                }
            }

            /**
             * ä¿å­˜æ—¶é—´è¡¨
             */
            async function saveSchedule() {
                // ä»æ‰€æœ‰checkboxè·å–å½“å‰é€‰æ‹©çŠ¶æ€
                const selectedTimes = [];
                document.querySelectorAll('.time-checkbox input:checked').forEach(checkbox => {
                    const date = checkbox.dataset.date;
                    const period = checkbox.dataset.period;
                    selectedTimes.push(Utils.getTimeKey(date, period));
                });
                
                await Schedule.savePlayerSchedule(playerId, selectedTimes);
                
                // ç”Ÿæˆå¤‡ä»½æ–‡ä»¶
                await generateBackupFile();
                
                // æ¸…é™¤æœªä¿å­˜æ ‡è®°
                hasUnsavedChanges = false;
                initialSelectedTimes = selectedTimes;
                
                // å»¶è¿Ÿè¿”å›ï¼Œè®©ç”¨æˆ·çœ‹åˆ°æˆåŠŸæç¤º
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 1000);
            }

            /**
             * æ¸…ç©ºé€‰æ‹©
             */
            async function clearSchedule() {
                if (Utils.confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰é€‰æ‹©å—ï¼Ÿ')) {
                    await Schedule.savePlayerSchedule(playerId, []);
                    await renderSchedule();

                    // æ›´æ–°åˆå§‹çŠ¶æ€
                    initialSelectedTimes = [];
                    hasUnsavedChanges = false;

                    Utils.showMessage('å·²æ¸…ç©ºé€‰æ‹©', 'success');
                }
            }

            /**
             * æ¸²æŸ“é€‰æ‰‹å†å²å¾—åˆ†å›¾è¡¨
             */
            async function renderScoreChart(playerId) {
                try {
                    console.log('å¼€å§‹æ¸²æŸ“å›¾è¡¨ï¼ŒplayerId:', playerId, 'æ—¶é—´:', new Date().toISOString());

                    // é˜²æ­¢é‡å¤æ¸²æŸ“
                    if (window.isRenderingChart) {
                        console.log('å›¾è¡¨æ­£åœ¨æ¸²æŸ“ä¸­ï¼Œè·³è¿‡é‡å¤è°ƒç”¨');
                        return;
                    }
                    window.isRenderingChart = true;

                    // è·å–å®¹å™¨å…ƒç´ ï¼ˆæå‰å£°æ˜ï¼Œé¿å…é‡å¤å£°æ˜ï¼‰
                    const chartContainer = document.querySelector('.score-chart-container');

                    // æ£€æŸ¥DOMå…ƒç´ 
                    let canvas = document.getElementById('scoreChart');
                    if (!canvas) {
                        console.warn('å›¾è¡¨ç”»å¸ƒå…ƒç´ æœªæ‰¾åˆ°');
                        window.isRenderingChart = false;
                        return;
                    }

                    // è·å–å†å²å¾—åˆ†æ•°æ®
                    const scoreData = await getPlayerScoreHistory(playerId);

                    if (scoreData.length === 0) {
                        // å¦‚æœæ²¡æœ‰å†å²æ•°æ®ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
                        canvas.style.display = 'none';
                        if (chartContainer) {
                            // ç§»é™¤ç°æœ‰çš„æ— æ•°æ®æ¶ˆæ¯
                            const existingMsg = chartContainer.querySelector('p');
                            if (existingMsg) {
                                existingMsg.remove();
                            }
                            const noDataMsg = document.createElement('p');
                            noDataMsg.textContent = 'æš‚æ— å†å²å¾—åˆ†è®°å½•';
                            noDataMsg.style.color = 'white';
                            noDataMsg.style.textAlign = 'center';
                            noDataMsg.style.fontStyle = 'italic';
                            chartContainer.appendChild(noDataMsg);
                        }
                        window.isRenderingChart = false;
                        return;
                    }

                    // æ˜¾ç¤ºç”»å¸ƒ
                    canvas.style.display = 'block';

                    // ç§»é™¤æ— æ•°æ®æ¶ˆæ¯
                    if (chartContainer) {
                        const existingMsg = chartContainer.querySelector('p');
                        if (existingMsg) {
                            existingMsg.remove();
                        }
                    }

                    // å½»åº•æ¸…ç†ä¹‹å‰çš„å›¾è¡¨å®ä¾‹å’ŒDOMå…ƒç´ 
                    if (window.scoreChartInstance) {
                        try {
                            console.log('é”€æ¯æ—§å›¾è¡¨å®ä¾‹');
                            window.scoreChartInstance.destroy();
                            window.scoreChartInstance = null;
                        } catch (destroyError) {
                            console.warn('é”€æ¯æ—§å›¾è¡¨å¤±è´¥:', destroyError);
                        }
                    }

                    // æ¸…ç†æ‰€æœ‰å¯èƒ½çš„Chartå®ä¾‹å¼•ç”¨
                    if (window.Chart && window.Chart.instances) {
                        console.log('æ¸…ç†Chartå®ä¾‹æ•°ç»„');
                        Object.keys(window.Chart.instances).forEach(key => {
                            try {
                                window.Chart.instances[key].destroy();
                                delete window.Chart.instances[key];
                            } catch (e) {
                                console.warn('æ¸…ç†Chartå®ä¾‹å¤±è´¥:', e);
                            }
                        });
                    }

                    // å®Œå…¨é‡å»ºcanvaså…ƒç´ ï¼Œé¿å…æ®‹ç•™çŠ¶æ€
                    if (chartContainer) {
                        // ç§»é™¤æ—§çš„canvas
                        const oldCanvas = chartContainer.querySelector('#scoreChart');
                        if (oldCanvas) {
                            oldCanvas.remove();
                        }

                        // åˆ›å»ºæ–°çš„canvas
                        const newCanvas = document.createElement('canvas');
                        newCanvas.id = 'scoreChart';
                        newCanvas.width = 400;
                        newCanvas.height = 200;

                        // é‡æ–°æ’å…¥åˆ°å®¹å™¨ä¸­ï¼ˆåœ¨h3åé¢ï¼‰
                        const h3 = chartContainer.querySelector('h3');
                        if (h3) {
                            h3.insertAdjacentElement('afterend', newCanvas);
                        } else {
                            chartContainer.appendChild(newCanvas);
                        }

                        // æ›´æ–°canvaså¼•ç”¨
                        canvas = newCanvas;
                    }

                    // è·å–canvasä¸Šä¸‹æ–‡ï¼ˆåœ¨canvaså¯èƒ½è¢«é‡æ–°èµ‹å€¼åï¼‰
                    const ctx = canvas.getContext('2d');

                    // åˆ›å»ºæ–°çš„æŠ˜çº¿å›¾
                    window.scoreChartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: scoreData.map(item => `ç¬¬${item.round}åœº`),
                            datasets: [{
                                label: 'åœºæ¬¡å¾—åˆ†',
                                data: scoreData.map(item => item.score),
                                borderColor: 'rgba(255, 255, 255, 0.9)',
                                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                pointBackgroundColor: 'rgba(255, 255, 255, 1)',
                                pointBorderColor: 'rgba(255, 255, 255, 1)',
                                pointBorderWidth: 2,
                                pointRadius: 6,
                                pointHoverRadius: 8
                            }]
                        },
                        options: {
                            responsive: false,
                            plugins: {
                                legend: {
                                    labels: {
                                        color: 'white',
                                        font: { size: 14 }
                                    }
                                },
                                tooltip: {
                                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                    titleColor: 'white',
                                    bodyColor: 'white',
                                    callbacks: {
                                        label: function(context) {
                                            return `å¾—åˆ†: ${context.parsed.y}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    ticks: {
                                        color: 'white',
                                        font: { size: 12 }
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.2)'
                                    }
                                },
                                y: {
                                    beginAtZero: false,
                                    ticks: {
                                        color: 'white',
                                        font: { size: 12 },
                                        callback: function(value) {
                                            return value.toFixed(1);
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.2)'
                                    }
                                }
                            },
                            elements: {
                                point: {
                                    hoverBorderWidth: 3
                                }
                            }
                        }
                    });

                    console.log('å›¾è¡¨æ¸²æŸ“å®Œæˆ');

                } catch (error) {
                    console.error('æ¸²æŸ“å›¾è¡¨å‡ºé”™:', error);
                    // é”™è¯¯å¤„ç†
                    const canvas = document.getElementById('scoreChart');
                    if (canvas) {
                        canvas.style.display = 'none';
                    }
                } finally {
                    // ç¡®ä¿æ ‡å¿—ä½è¢«é‡ç½®
                    window.isRenderingChart = false;
                }
            }

            /**
             * è·å–é€‰æ‰‹çš„å†å²å¾—åˆ†æ•°æ®
             */
            async function getPlayerScoreHistory(playerId) {
                try {
                    const games = await Storage.getGames();

                    // æŒ‰åœºæ¬¡æ•´ç†å¾—åˆ†æ•°æ®
                    const scoreHistory = [];

                    games.forEach(game => {
                        if (game.isCompleted && game.tables) {
                            let totalScore = 0;
                            let participated = false;

                            // è®¡ç®—è¯¥é€‰æ‰‹åœ¨è¯¥åœºæ¬¡çš„æ‰€æœ‰æ¡Œå­çš„å¾—åˆ†æ€»å’Œ
                            game.tables.forEach(table => {
                                if (table.players && table.players.includes(playerId)) {
                                    participated = true;
                                    const score = table.scores ? table.scores[playerId] || 0 : 0;
                                    totalScore = parseFloat((totalScore + score).toFixed(1));
                                }
                            });

                            if (participated) {
                                scoreHistory.push({
                                    round: game.round,
                                    score: totalScore
                                });
                            }
                        }
                    });

                    // æŒ‰åœºæ¬¡æ’åº
                    return scoreHistory.sort((a, b) => a.round - b.round);
                } catch (error) {
                    console.error('è·å–é€‰æ‰‹å†å²å¾—åˆ†å¤±è´¥:', error);
                    return [];
                }
            }
        })();
    </script>
</body>
</html>

